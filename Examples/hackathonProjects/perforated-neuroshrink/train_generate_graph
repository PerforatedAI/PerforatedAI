import torch
import torch.nn as nn
import torch.optim as optim
from torchvision import datasets, transforms

from perforatedai import utils_perforatedai as UPA
from perforatedai import globals_perforatedai as GPA


# ---------------- MODEL ----------------
class Net(nn.Module):
    def __init__(self):
        super().__init__()
        self.conv1 = nn.Conv2d(1, 32, 3, 1)
        self.conv2 = nn.Conv2d(32, 64, 3, 1)
        self.fc1 = nn.Linear(9216, 128)
        self.fc2 = nn.Linear(128, 10)

    def forward(self, x):
        x = self.conv1(x)
        x = torch.relu(x)
        x = self.conv2(x)
        x = torch.relu(x)
        x = torch.max_pool2d(x, 2)
        x = torch.flatten(x, 1)
        x = self.fc1(x)
        x = torch.relu(x)
        x = self.fc2(x)
        return torch.log_softmax(x, dim=1)


# ---------------- MAIN ----------------
def main():
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

    transform = transforms.Compose([
        transforms.ToTensor(),
        transforms.Normalize((0.1307,), (0.3081,))
    ])

    train_loader = torch.utils.data.DataLoader(
        datasets.MNIST("./data", train=True, download=True, transform=transform),
        batch_size=64,
        shuffle=True
    )

    test_loader = torch.utils.data.DataLoader(
        datasets.MNIST("./data", train=False, transform=transform),
        batch_size=1000,
        shuffle=False
    )

    # Reduce logs
    GPA.pc.set_verbose(False)

    model = Net().to(device)

    # ðŸ”‘ THIS LINE GENERATES THE REQUIRED PAI GRAPH
    model = UPA.initialize_pai(model, save_name="PAI")

    GPA.pai_tracker.set_optimizer(optim.Adam)

    optimizer = GPA.pai_tracker.setup_optimizer(
        model,
        {"params": model.parameters(), "lr": 1e-3},
        None
    )

    # -------- ONE TRAINING PASS (ENOUGH FOR GRAPH) --------
    model.train()
    correct = 0

    for data, target in train_loader:
        data, target = data.to(device), target.to(device)
        optimizer.zero_grad()
        output = model(data)
        loss = nn.functional.nll_loss(output, target)
        loss.backward()
        optimizer.step()

        pred = output.argmax(dim=1)
        correct += pred.eq(target).sum().item()

    train_acc = 100.0 * correct / len(train_loader.dataset)
    GPA.pai_tracker.add_extra_score(train_acc, "train")
    print(f"Train Accuracy: {train_acc:.2f}%")

    # -------- ONE VALIDATION PASS (GRAPH FINALIZED HERE) --------
    model.eval()
    correct = 0
    with torch.no_grad():
        for data, target in test_loader:
            data, target = data.to(device), target.to(device)
            output = model(data)
            pred = output.argmax(dim=1)
            correct += pred.eq(target).sum().item()

    val_acc = 100.0 * correct / len(test_loader.dataset)
    print(f"Validation Accuracy: {val_acc:.2f}%")

    GPA.pai_tracker.add_validation_score(val_acc, model)

    print("\nâœ… DONE")
    print("ðŸ“Š Required graph generated at: PAI/PAI.png")


if __name__ == "__main__":
    main()
